using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.CompilerServices;
using SBSEngine.Runtime;

namespace SBSEngine.Runtime.Binder
{
    public static class BinaryOperationDelegate
    {
        public static bool BothNumeric(object x, object y)
        {
            if (IsNumeric(x) && IsNumeric(y))
                return true;
            return false;
        }

        public static bool IsNumeric(object o)
        {
            switch (Type.GetTypeCode(o.GetType()))
            {
                case TypeCode.Int32:
                case TypeCode.Double:
                    return true;
                default:
                    return false;
            }
        }

        #region Add Operation Methods
        public static T AddOperation<T>(object left, object right)
        {
            if (BothNumeric(left, right))
            {
                if (left.GetType() == right.GetType())
                {
                    if (left.GetType() == typeof(int))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(IntAdd);
                    else if (left.GetType() == typeof(double))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(DoubleAdd);
                }
                else
                {
                    if (left.GetType() == typeof(double))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(DoubleAddInt);
                    else
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(IntAddDouble);
                }
            }

            return default(T);
        }

        public static object IntAdd(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(int) && right.GetType() == typeof(int))
            {
                return (int)left + (int)right;
            }

            return Update(site, left, right, op);
        }

        public static object DoubleAdd(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(double) && right.GetType() == typeof(double))
            {
                return (double)left + (double)right;
            }

            return Update(site, left, right, op);
        }

        public static object IntAddDouble(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(int) && right.GetType() == typeof(double))
            {
                return (int)left + (double)right;
            }

            return Update(site, left, right, op);
        }

        public static object DoubleAddInt(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(double) && right.GetType() == typeof(int))
            {
                return (double)left + (int)right;
            }

            return Update(site, left, right, op);
        }
        #endregion

        // Copy-Paste Code starts here. Following code are based on Add Operation Methods, generated by using "Find and Replace".
        #region Substract Operation Methods
        public static T SubtractOperation<T>(object left, object right)
        {
            if (BothNumeric(left, right))
            {
                if (left.GetType() == right.GetType())
                {
                    if (left.GetType() == typeof(int))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(IntSubtract);
                    else if (left.GetType() == typeof(double))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(DoubleSubtract);
                }
                else
                {
                    if (left.GetType() == typeof(double))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(DoubleSubtractInt);
                    else
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(IntSubtractDouble);
                }
            }

            return default(T);
        }

        public static object IntSubtract(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(int) && right.GetType() == typeof(int))
            {
                return (int)left - (int)right;
            }

            return Update(site, left, right, op);
        }

        public static object DoubleSubtract(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(double) && right.GetType() == typeof(double))
            {
                return (double)left - (double)right;
            }

            return Update(site, left, right, op);
        }

        public static object IntSubtractDouble(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(int) && right.GetType() == typeof(double))
            {
                return (int)left - (double)right;
            }

            return Update(site, left, right, op);
        }

        public static object DoubleSubtractInt(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(double) && right.GetType() == typeof(int))
            {
                return (double)left - (int)right;
            }

            return Update(site, left, right, op);
        }
        #endregion

        #region Multiply Operation Methods
        public static T MultiplyOperation<T>(object left, object right)
        {
            if (BothNumeric(left, right))
            {
                if (left.GetType() == right.GetType())
                {
                    if (left.GetType() == typeof(int))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(IntMultiply);
                    else if (left.GetType() == typeof(double))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(DoubleMultiply);
                }
                else
                {
                    if (left.GetType() == typeof(double))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(DoubleMultiplyInt);
                    else
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(IntMultiplyDouble);
                }
            }

            return default(T);
        }

        public static object IntMultiply(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(int) && right.GetType() == typeof(int))
            {
                return (int)left * (int)right;
            }

            return Update(site, left, right, op);
        }

        public static object DoubleMultiply(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(double) && right.GetType() == typeof(double))
            {
                return (double)left * (double)right;
            }

            return Update(site, left, right, op);
        }

        public static object IntMultiplyDouble(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(int) && right.GetType() == typeof(double))
            {
                return (int)left * (double)right;
            }

            return Update(site, left, right, op);
        }

        public static object DoubleMultiplyInt(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(double) && right.GetType() == typeof(int))
            {
                return (double)left * (int)right;
            }

            return Update(site, left, right, op);
        }
        #endregion

        #region Divide Operation Methods
        public static T DivideOperation<T>(object left, object right)
        {
            if (BothNumeric(left, right))
            {
                if (left.GetType() == right.GetType())
                {
                    if (left.GetType() == typeof(int))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(IntDivide);
                    else if (left.GetType() == typeof(double))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(DoubleDivide);
                }
                else
                {
                    if (left.GetType() == typeof(double))
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(DoubleDivideInt);
                    else
                        return (T)(Object)new Func<CallSite, object, object, SBSOperator, object>(IntDivideDouble);
                }
            }

            return default(T);
        }

        public static object IntDivide(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(int) && right.GetType() == typeof(int))
            {
                return (int)left / (int)right;
            }

            return Update(site, left, right, op);
        }

        public static object DoubleDivide(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(double) && right.GetType() == typeof(double))
            {
                return (double)left / (double)right;
            }

            return Update(site, left, right, op);
        }

        public static object IntDivideDouble(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(int) && right.GetType() == typeof(double))
            {
                return (int)left / (double)right;
            }

            return Update(site, left, right, op);
        }

        public static object DoubleDivideInt(CallSite site, object left, object right, SBSOperator op)
        {
            if (left.GetType() == typeof(double) && right.GetType() == typeof(int))
            {
                return (double)left / (int)right;
            }

            return Update(site, left, right, op);
        }
        #endregion
        // Copy-Paste Code ends here.



        public static object IntAddMethod(object left, object right)
        {
            return (int)left + (int)right;
        }

        public static object DoubleAddMethod(object left, object right)
        {
            return (double)left + (double)right;
        }

        // TODO: Remove this.
        public static object HitOrUpdate(CallSite site, object left, object right, Type leftType, Type rightType , SBSOperator op , Func<object,object,object> method)
        {
            if (left.GetType() == leftType && right.GetType() == rightType)
                return method(right,left);
            return ((CallSite<Func<CallSite, object, object, SBSOperator, object>>)site).Update(site, left, right, op);
        }

        public static bool IfHitChecker(object left,object right,Type leftType,Type rightType)
        {
            if (left.GetType() == leftType && right.GetType() == rightType)
                return true;
            return false;
        }

        public static object Update(CallSite site, object left, object right, SBSOperator op)
        {
            return ((CallSite<Func<CallSite, object, object, SBSOperator, object>>)site).Update(site, left, right, op);
        }

    }
}
